<details open><summary><strong>Python 2 or Python 3?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Python 3.6 (Except for dataclasses and asyncio that require version 3.7).
</details><br>

<details open><summary><strong>What is the best way to use it?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;I keep the text file open on separate desktop at all times. It is also in a different text editor than the one I usually use, so it's easier to switch to with <code>Ctrl+↹</code> / <code>⌘↹</code>. Cheatsheet consists of minimal text and short examples so things are easy to find with <code>Ctrl+F</code> / <code>⌘F</code>. If you're on the webpage, searching for <code>'#&lt;name&gt;'</code> will only search for the titles.<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;I also keep the Python console open at all times to test little snippets of code, to check out the available functions of a module using code completion and above all, to use <code>help(&lt;module/object/function/type/str&gt;)</code> command. If something is still unclear, then I search the Python docs by googling <code>'python docs &lt;module/function&gt;'</code>.
</details><br>

<details open><summary><strong>What does the '&lt;type&gt;' signify?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;It is a placeholder for an object. It needs to be replaced by an expression, literal or a variable that returns/is of that type.
</details><br>

<details open><summary><strong>Why the '&lt;type&gt;' semantics?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;It makes examples much less ambiguous.
</details><br>

<details open><summary><strong>Why are some basics like <code>'&lt;list&gt; = [&lt;el_1&gt;, &lt;el_2&gt;, ...]'</code> and <code>'&lt;el&gt; = &lt;list&gt;[&lt;int&gt;]'</code> missing?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;This cheatsheet is not intended for complete beginners. This way it can save some valuable space. Nonetheless, it tries to be simple enough to be useful for somebody who completed the introductory course. A nice one-page cheatsheet that can help you get started can be found <a href="https://github.com/kickstartcoding/cheatsheets/blob/master/build/topical/python.pdf">here</a>.</details><br>

<details open><summary><strong>What exactly is <code>&lt;el&gt;</code>?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;El is short for element and can be any object, but it usually denotes an object that is an item of a collection.
</details><br>

<details open><summary><strong>What exactly is <code>&lt;collection&gt;</code>?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Collection is my name for an iterable object. An iterable object in Python is any object that has at least one of iter() and getitem() special methods defined. By convention, <code>&lt;object&gt;.__iter__()</code> should return an iterator of object's items and <code>&lt;object&gt;.__getitem__(&lt;index&gt;)</code> an item at that index. I chose not to use the name iterable because it sounds scarier and more vague than collection, even though it has a precise definition.<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;To make matters a bit more confusing, an abstract base class called Iterable doesn't fully follow this definition. An expression <code>instanceof(&lt;object&gt;, collections.abc.Iterable)</code> only checks whether an object has iter() special method, disregarding the getitem().<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;Although collection has no definition in Python's <a href="https://docs.python.org/3/glossary.html">glossary</a>, there exists a Collection abstract base class. Expression <code>instanceof(&lt;object&gt;, collections.abc.Collection)</code> returns 'True' for any object that has len(), iter() and contains() special methods defined. <code>&lt;object&gt;.__len__()</code> should return the number of elements and <code>&lt;object&gt;.__contains__(&lt;el&gt;)</code> should check if object contains the passed element.
</details><br>

<details open><summary><strong>What about PEP 8?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Check out <a href="https://google.github.io/styleguide/pyguide.html">Google Style Guide</a> and use <code>Ctrl+Alt+L</code> / <code>⌥⌘L</code> shortcut in PyCharm to automatically reformat code.
</details><br>

<details open><summary><strong>Why are there no blank lines between method definitions?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;This way classes can be copy-pasted into the Python console, which would otherwise raise IndentationError.
</details><br>

<details open><summary><strong>Why are import statements, virtual environments and tests not covered?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Check out <a href="https://docs.python-guide.org/">The Hitchhiker’s Guide to Python</a> for a nice overview of the mentioned topics.
</details><br>

<details open><summary><strong>Why are Flask and Django not covered?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Maybe they will be in the future. For now, here is a nice <a href="https://github.com/kickstartcoding/cheatsheets/blob/master/build/topical/django.jpg">Django cheatsheet</a>.
</details><br>

<details open><summary><strong>Why are there no concrete Regex examples?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Regular expressions are a separate technology that is independent from Python. There are many resources available online.
</details><br>

<details open><summary><strong>Why is there no old style string formating?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Because it is redundant and I don't want to encourage its use.
</details><br>

<details open><summary><strong>Why is staticmethod decorator not covered in Class section?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Because it is of very limited use and is easy to mix up with classmethod.
</details><br>

<details open><summary><strong>Why are descriptors not covered?</strong></summary><br>
&nbsp;&nbsp;&nbsp;&nbsp;Because property decorator is sufficient for everyday use.
</details><br>